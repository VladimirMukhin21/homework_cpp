# Занятие 4: Функции и указатели

**Длительность:** 2 пары (4 академических часа)

## Цели занятия
- Изучить синтаксис объявления и определения функций
- Понять механизм передачи параметров
- Освоить работу с указателями
- Изучить ссылки (references)

---

## Пара 1: Функции

### Теоретический материал

### Объявление и определение функций

```cpp
// Объявление (прототип)
int add(int a, int b);

// Определение
int add(int a, int b) {
    return a + b;
}
```

### Передача параметров

#### По значению
```cpp
void modify(int x) {
    x = 100;  // Не изменяет оригинальную переменную
}
```

#### По указателю
```cpp
void modify(int* x) {
    *x = 100;  // Изменяет оригинальную переменную
}

int value = 10;
modify(&value);  // value теперь равен 100
```

#### По ссылке
```cpp
void modify(int& x) {
    x = 100;  // Изменяет оригинальную переменную
}

int value = 10;
modify(value);  // value теперь равен 100
```

### Указатели

```cpp
int x = 10;
int* ptr = &x;      // ptr указывает на x
int value = *ptr;   // Разыменование: value = 10
*ptr = 20;          // x теперь равен 20
```

### Ссылки

```cpp
int x = 10;
int& ref = x;       // ref - это псевдоним для x
ref = 20;           // x теперь равен 20
```

### Разница между указателями и ссылками
- Указатель может быть `nullptr`, ссылка - нет
- Указатель можно переназначить, ссылку - нет
- Указатель требует явного разыменования, ссылка - нет

---

## Пара 2: Указатели и ссылки

### Теоретический материал

#### Работа с указателями

```cpp
int x = 10;
int* ptr = &x;        // ptr хранит адрес x
int value = *ptr;     // Разыменование: получаем значение
*ptr = 20;            // Изменяем значение через указатель

// Указатель на указатель
int** pptr = &ptr;
int val = **pptr;     // Двойное разыменование
```

#### Арифметика указателей

```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* p = arr;         // p указывает на arr[0]
p++;                  // p теперь указывает на arr[1]
p += 2;               // p теперь указывает на arr[3]
int diff = p - arr;   // Разница в индексах: 3
```

#### Указатель nullptr

```cpp
int* ptr = nullptr;   // Современный способ (C++11)
// int* ptr = NULL;   // Устаревший способ

if (ptr != nullptr) {
    *ptr = 10;
}
```

#### Ссылки (references)

```cpp
int x = 10;
int& ref = x;         // ref - это псевдоним для x
ref = 20;             // x теперь равен 20

// Ссылка не может быть переназначена
int y = 30;
// ref = y;           // Это присваивание, а не переназначение
// int& ref2;         // ОШИБКА! Ссылка должна быть инициализирована
```

#### Ссылки как параметры функций

```cpp
void swap(int& a, int& b) {
    int temp = a;
    a = b;
    b = temp;
}

int x = 10, y = 20;
swap(x, y);  // x = 20, y = 10
```

#### Константные ссылки

```cpp
void print(const int& value) {
    // value нельзя изменить
    std::cout << value << std::endl;
}

// Эффективно для больших объектов
void process(const std::string& str) {
    // str передается по ссылке, но не копируется
}
```

### Практические примеры

```cpp
// Функция обмена значений
void swap(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

// Или через ссылки
void swap(int& a, int& b) {
    int temp = a;
    a = b;
    b = temp;
}

// Функция возвращающая указатель
int* findMax(int arr[], int size) {
    if (size == 0) return nullptr;

    int* max = arr;
    for (int i = 1; i < size; ++i) {
        if (arr[i] > *max) {
            max = arr + i;
        }
    }
    return max;
}
```

### Домашнее задание
- Реализовать функцию для обмена значений двух переменных (через указатели и ссылки)
- Написать функцию, которая принимает массив и его размер, возвращает указатель на максимальный элемент
- Изучить разницу между передачей по значению, указателю и ссылке
- Создать функцию, которая принимает указатель на функцию как параметр

### Дополнительные материалы
- Указатели на функции
- Функции с переменным числом аргументов
- Перегрузка функций
- Умные указатели (введение)

